==============================================================================
*vim.async*

This module implements an asynchronous programming library for Neovim,
centered around the principle of **Structured Concurrency**. This design
makes concurrent programs easier to reason about, more reliable, and less
prone to resource leaks.

                                       *Core Philosophy: Structured Concurrency*

Every async operation happens within a "concurrency scope", which is represented
by a |vim.async.Task| object created with `vim.async.run()`. This creates a
parent-child relationship between tasks, with the following guarantees:

1.  **Task Lifetime:** A parent task's scope cannot end until all of its
child tasks have completed. The parent *implicitly waits* for its children,
preventing orphaned or "fire-and-forget" tasks.

2.  **Error Propagation:** If a child task fails with an error, the error is
propagated up to its parent.

3.  **Cancellation Propagation:** If a parent task is cancelled (e.g., via
`:close()`), the cancellation is propagated down to all of its children.

This model ensures that all concurrent tasks form a clean, hierarchical tree,
and control flow is always well-defined.

                             *Stackful vs. Stackless Coroutines (Green Threads)*

A key architectural feature of `async.nvim` is that it is built on Lua's
native **stackful coroutines**. This provides a significant advantage over the
`async/await` implementations in many other popular languages, though it's
important to clarify its role in the "function coloring" problem.

- **Stackful (Lua, Go):** A stackful coroutine has its own dedicated call
stack, much like a traditional OS thread (and are often called "green threads"
or "virtual threads"). This allows a coroutine to be suspended from deep
within a nested function call. When using `async.nvim`, `vim.async.run()`
serves as the explicit entry point to an asynchronous context (similar to
Go's `go` keyword). However, *within* that `async.run()` context,
intermediate synchronous helper functions do *not* need to be specially
marked. This means if function `A` calls `B` calls `C`, and `C` performs
an `await`, `A` and `B` can remain regular Lua functions as long as they are
called from within an `async.run()` context. This significantly reduces the
viral spread of "coloring".

- **Stackless (JavaScript, Python, Swift, C#, Kotlin):** Most languages
implement `async/await` with stackless coroutines. A function that can
be suspended must be explicitly marked with a keyword (like `async` or
`suspend`). This requirement is "viral"—any function that calls an `async`
function must itself be marked `async`, and so on up the call stack. This
is the typical "function coloring" problem.

Because Lua provides stackful coroutines, `async.nvim` allows you to `await`
from deeply nested synchronous functions *within an async context* without
"coloring" those intermediate callers. This makes concurrent code less
intrusive and easier to integrate with existing synchronous code, despite
`async.run()` providing an explicit boundary for the async operations.

                                                                  *Key Features*

- **Task Scopes:** Create a new concurrency scope with `vim.async.run()`.
The returned |vim.async.Task| object acts as the parent for any other
tasks started within its function.

- **Awaiting:** Suspend execution and wait for an operation to complete using
`vim.async.await()`. This can be used on other tasks or on callback-based
functions.

- **Callback Wrapping:** Convert traditional callback-based functions into
modern async functions with `vim.async.wrap()`.

- **Concurrency Utilities:** `await_all`, `await_any`, and `iter` provide
powerful tools for managing groups of tasks.

- **Synchronization Primitives:** `event`, `queue`, and `semaphore` are
available for more complex coordination patterns.

                                                                       *Example*

>lua
 -- Create an async version of vim.system
 local system = vim.async.wrap(3, vim.system)

 -- vim.async.run() creates a parent task scope.
 local parent_task = vim.async.run(function()
   -- These child tasks are launched within the parent's scope.
   local ls_task = system({ 'ls', '-l' })
   local date_task = system({ 'date' })

   -- The parent task will not complete until both ls_task and
   -- date_task have finished, even without an explicit 'await'.
 end)

 -- Wait for the parent and all its children to complete.
 parent_task:wait()
<

                                        *Structured Concurrency and Task Scopes*

Every call to `vim.async.run(fn)` creates a new |vim.async.Task| that establishes
a concurrency scope. Any other tasks started inside `fn` become children of this
task.

>lua
 -- t1 is a top-level task with no parent.
 local t1 = async.run(function() vim.async.sleep(50) end)

 local main = async.run(function()
   -- 'child' is created within main's scope, so 'main' is its parent.
   local child = async.run(function() vim.async.sleep(100) end)

   -- Because 'main' is the parent, it implicitly waits for 'child'
   -- to complete before it can complete itself.

   -- Cancellation is also propagated down the tree.
   -- Calling main:close() will also call child:close().

   -- t1 created outside of the main async context.
   -- It has no parent, so 'main' does not implicitly wait for it.
   async.await(t1)
 end)

 -- This will wait for ~100ms, as 'main' must wait for 'child'.
 main:wait()
<

If a parent task finishes with an error, it will immediately cancel all of its
running child tasks. If it finishes normally, it implicitly waits for them to
complete normally.

                                                 *Comparison with Python's Trio*

The design of `async.nvim` is heavily inspired by Python's `trio` library,
and it implements the same core philosophy of **Structured Concurrency**.
Both libraries guarantee that all tasks are run in a hierarchy, preventing
leaked or "orphaned" tasks and ensuring that cancellation and errors
propagate predictably.

Trio uses an explicit `nursery` object. To spawn child tasks, you must
create a nursery scope (e.g., `async with trio.open_nursery() as nursery:`),
and the nursery block defines the lifetime of the child tasks.

async.nvim unifies the concepts of a task and a concurrency scope.
The |vim.async.Task| object returned by `vim.async.run()` *is* the scope.
In essence, `async.nvim` provides the same safety and clarity as `trio` but
adapts the concepts idiomatically for Lua and Neovim.

                                         *Comparison with JavaScript's Promises*

JavaScript's `async/await` model with Promises is fundamentally **unstructured**.
While tools like `Promise.all` can coordinate multiple promises, the language
provides no built-in "scope" that automatically manages child tasks.

An `async` function call in JavaScript returns a Promise
that runs independently. If it is not explicitly awaited, it can easily
become an "orphaned" task.

Cancellation is manual and opt-in via the `AbortController`
and `AbortSignal` pattern. It does not automatically propagate from a parent
scope to child operations.

`async.nvim`'s structured model contrasts with this by providing automatic
cleanup and cancellation, preventing common issues like resource leaks from
forgotten background tasks.

                                             *Comparison with Swift Concurrency*

Swift's concurrency model maps closely to `async.nvim`.

Swift's `TaskGroup` is analogous to the concurrency scope
created by `vim.async.run()`. The group's scope cannot exit until all
child tasks added to it are complete.

In both Swift and `async.nvim`, cancelling a parent task
automatically propagates a cancellation notice down to all of its children.

                                             *Comparison with Kotlin Coroutines*

Kotlin's Coroutine framework is another system built on **Structured Concurrency**,
and it shares a nearly identical philosophy with `async.nvim`.

In Kotlin, a `coroutineScope` function creates a new
scope. The scope is guaranteed not to complete until all coroutines
launched within it have also completed. This is conceptually the same as
the scope created by `vim.async.run()`.

Like `async.nvim`, cancellation and errors
propagate automatically through the task hierarchy. Cancelling a parent scope
cancels its children, and an exception in a child will cancel the parent.

                                                 *Comparison with Go Goroutines*

Go's concurrency model, while powerful, is fundamentally **unstructured**.
Launching a `go` routine is a "fire-and-forget" operation with no implicit
parent-child relationship.

Programmers must manually track groups of goroutines,
typically using a `sync.WaitGroup` to ensure they all complete before
proceeding.

Cancellation and deadlines are handled by
explicitly passing a `context` object through the entire call stack. There
is no automatic propagation of cancellation or errors up or down a task tree.

This contrasts with `async.nvim`, where the structured concurrency model
automates the lifetime, cancellation, and error management that must be
handled explicitly in Go.

------------------------------------------------------------------------------
vim.async.run({...})                                         *vim.async.run()*

    Run a function in an async context, asynchronously.

    Returns an |vim.async.Task| object which can be used to wait or await the result
    of the function.

    Examples:
    >lua
     -- Run a uv function and wait for it
     local stat = vim.async.run(function()
         return vim.async.await(2, vim.uv.fs_stat, 'foo.txt')
     end):wait()

     -- Since uv functions have sync versions, this is the same as:
     local stat = vim.fs_stat('foo.txt')
<

    Generics: ~
    - `T`, `R`

    Overloads: ~
    - `fun(func: async fun(...: T ...), ...: T ...) -> Task<R ...>`
    - `fun(name: string, func: async fun(...: T ...), ...: T ...) -> Task<R ...>`
    - `fun(opts: vim.async.run.Opts, func: async fun(...: T ...), ...: T ...) -> Task<R ...>`

    Parameters: ~
    - {...} (`any`)

    Returns: ~
    - (`Task<R ...>`)

------------------------------------------------------------------------------
vim.async.await({...})                                     *vim.async.await()*

    Asynchronous blocking wait

    Example:
    >lua
     local task = vim.async.run(function()
        return 1, 'a'
     end)

     local task_fun = vim.async.async(function(arg)
        return 2, 'b', arg
     end)

     vim.async.run(function()
       do -- await a callback function
         vim.async.await(1, vim.schedule)
       end

       do -- await a callback function (if function only has a callback argument)
         vim.async.await(vim.schedule)
       end

       do -- await a task (new async context)
         local n, s = vim.async.await(task)
         assert(n == 1 and s == 'a')
       end

     end)
<

    Attributes: ~
    - `async`

    Generics: ~
    - `T`, `R`

    Overloads: ~
    - `async fun(func: fun(callback: fun(...: R ...)) -> vim.async.Closable?) -> R ...`
    - `async fun(argc: integer, func: fun(...: T ..., callback: fun(...: R ...)) -> vim.async.Closable?, ...: T ...) -> R ...`
    - `async fun(task: Task<R>) -> R ...`

    Parameters: ~
    - {...} (`any`): see overloads

    Returns: ~
    - (`any ...`)

------------------------------------------------------------------------------
vim.async.is_closing()                                *vim.async.is_closing()*

    Returns true if the current task has been closed.

    Can be used in an async function to do cleanup when a task is closing.

    Returns: ~
    - (`boolean`)

------------------------------------------------------------------------------
vim.async.wrap({argc}, {func})                              *vim.async.wrap()*

    Creates an async function with a callback style function.

    `func` can optionally return an object with a close method to clean up
    resources. Note this method will be called when the task finishes or
    interrupted.

    Example:

    >lua
     --- Note the callback argument is not present in the return function
     --- @type async fun(timeout: integer)
     local sleep = vim.async.wrap(2, function(timeout, callback)
       local timer = vim.uv.new_timer()
       timer:start(timeout * 1000, 0, callback)
       -- uv_timer_t provides a close method so timer will be
       -- cleaned up when this function finishes
       return timer
     end)

     vim.async.run(function()
       print('hello')
       sleep(2)
       print('world')
     end)
<

    Generics: ~
    - `T`, `R`

    Parameters: ~
    - {argc} (`integer`)
    - {func} (`fun(...: T ..., callback: fun(...: R ...)) -> vim.async.Closable?`)

    Returns: ~
    - (`async fun(...: T ...) -> R ...`)

------------------------------------------------------------------------------
vim.async.iter({tasks})                                     *vim.async.iter()*

    Waits for multiple tasks to finish and iterates over their results.

    This function allows you to run multiple asynchronous tasks concurrently and
    process their results as they complete. It returns an iterator function that
    yields the index of the task, any error encountered, and the results of the
    task.

    If a task completes with an error, the error is returned as the second
    value. Otherwise, the results of the task are returned as subsequent values.

    Example:
    >lua
     local task1 = vim.async.run(function()
       return 1, 'a'
     end)

     local task2 = vim.async.run(function()
       return 2, 'b'
     end)

     local task3 = vim.async.run(function()
       error('task3 error')
     end)

     vim.async.run(function()
       for i, err, r1, r2 in vim.async.iter({task1, task2, task3}) do
         print(i, err, r1, r2)
       end
     end)
<

    Prints:
<
     1 nil 1 'a'
     2 nil 2 'b'
     3 'task3 error' nil nil
<

    Attributes: ~
    - `async`

    Generics: ~
    - `R`

    Parameters: ~
    - {tasks} (`Task<R>[]`): A list of tasks to wait for and iterate over.

    Returns: ~
    - {iterator} (`async fun() -> (integer?,any,unknown)`): that yields the index, error, and results of each task.

------------------------------------------------------------------------------
vim.async.await_all({tasks})                           *vim.async.await_all()*

    Wait for all tasks to finish and return their results.

    Example:
    >lua
     local task1 = vim.async.run(function()
       return 1, 'a'
     end)

     local task2 = vim.async.run(function()
       return 1, 'a'
     end)

     local task3 = vim.async.run(function()
       error('task3 error')
     end)

     vim.async.run(function()
       local results = vim.async.await_all({task1, task2, task3})
       print(vim.inspect(results))
     end)
<

    Prints:
<
     {
       |1| = { nil, 1, 'a' },
       |2| = { nil, 2, 'b' },
       |3| = { 'task2 error' },
     }
<

    Attributes: ~
    - `async`

    Parameters: ~
    - {tasks} (`Task<any>[]`)

    Returns: ~
    - (`table<integer,unknown>`)

------------------------------------------------------------------------------
vim.async.await_any({tasks})                           *vim.async.await_any()*

    Wait for the first task to complete and return its result.

    Example:
    >lua
     local task1 = vim.async.run(function()
       vim.async.sleep(100)
       return 1, 'a'
     end)

     local task2 = vim.async.run(function()
       return 2, 'b'
     end)

     vim.async.run(function()
       local i, err, r1, r2 = vim.async.await_any({task1, task2})
       assert(i == 2)
       assert(err == nil)
       assert(r1 == 2)
       assert(r2 == 'b')
     end)
<

    Attributes: ~
    - `async`

    Parameters: ~
    - {tasks} (`Task<any>[]`)

    Returns: ~
    - {index} (`integer?`)
    - {err} (`any`)
    - {results} (`any ...`)

------------------------------------------------------------------------------
vim.async.sleep({duration})                                *vim.async.sleep()*

    Asynchronously sleep for a given duration.

    Blocks the current task for the given duration, but does not block the main
    thread.

    Attributes: ~
    - `async`

    Parameters: ~
    - {duration} (`integer`): ms


------------------------------------------------------------------------------
vim.async.timeout({duration}, {task})                    *vim.async.timeout()*

    Run a task with a timeout.

    If the task does not complete within the specified duration, it is closed
    and an error is thrown.

    Attributes: ~
    - `async`

    Generics: ~
    - `R`

    Parameters: ~
    - {duration} (`integer`): Timeout duration in milliseconds
    - {task} (`Task<R>`)

    Returns: ~
    - (`R`)

------------------------------------------------------------------------------
vim.async.semaphore({permits})                         *vim.async.semaphore()*

    Create an async semaphore that allows up to a given number of acquisitions.

    >lua
     vim.async.run(function()
       local semaphore = vim.async.semaphore(2)

       local tasks = {}

       local value = 0
       for i = 1, 10 do
         tasks|i| = vim.async.run(function()
           semaphore:with(function()
             value = value + 1
             vim.async.sleep(10)
             print(value) -- Never more than 2
             value = value - 1
           end)
         end)
       end

       vim.async.await_all(tasks)
       assert(value <= 2)
     end)
<

    Parameters: ~
    - {permits} (`integer?`): (default: 1)

    Returns: ~
    - (`vim.async.Semaphore`) (See |vim.async.Semaphore|)

==============================================================================
*vim.async.Closable*
------------------------------------------------------------------------------
*vim.async.Closable.close*
    Type: `fun(self, callback: (fun(...) -> ...)?)


==============================================================================
*vim.async.Event*

An event can be used to notify multiple tasks that some event has
happened. An Event object manages an internal flag that can be set to true
with the `set()` method and reset to `false` with the `clear()` method.
The `wait()` method blocks until the flag is set to `true`. The flag is
set to `false` initially.

------------------------------------------------------------------------------
vim.async.Event:set({max_woken})                       *vim.async.Event:set()*

    Set the event.

    All tasks waiting for event to be set will be immediately awakened.

    If `max_woken` is provided, only up to `max_woken` waiters will be woken.
    The event will be reset to `false` if there are more waiters remaining.

    Parameters: ~
    - {max_woken} (`integer?`)


------------------------------------------------------------------------------
vim.async.Event:wait()                                *vim.async.Event:wait()*

    Wait until the event is set.

    If the event is set, return immediately. Otherwise block until another
    task calls set().

    Attributes: ~
    - `async`


------------------------------------------------------------------------------
vim.async.Event:clear()                              *vim.async.Event:clear()*

    Clear (unset) the event.

    Tasks awaiting on wait() will now block until the set() method is called
    again.


==============================================================================
*vim.async.Future*

Future objects are used to bridge low-level callback-based code with
high-level async/await code.

------------------------------------------------------------------------------
vim.async.Future:completed()                    *vim.async.Future:completed()*

    Return `true` if the Future is completed.

    Returns: ~
    - (`boolean`)

------------------------------------------------------------------------------
vim.async.Future:result()                          *vim.async.Future:result()*

    Return the result of the Future.

    If the Future is done and has a result set by the `complete()` method, the
    result is returned.

    If the Future’s result isn’t yet available, this method raises a
    "Future has not completed" error.

    Returns: ~
    - {stat} (`boolean`): true if the Future completed successfully, false otherwise.
    - {error} (`any ...`): or result

------------------------------------------------------------------------------
vim.async.Future:wait({callback})                    *vim.async.Future:wait()*

    Add a callback to be run when the Future is done.

    The callback is called with the arguments:
    - (`err: string`) - if the Future completed with an error.
    - (`nil`, `...:any`) - the results of the Future if it completed successfully.

    If the Future is already done when this method is called, the callback is
    called immediately with the results.

    Parameters: ~
    - {callback} (`fun(err: any, ...: any)`)


------------------------------------------------------------------------------
vim.async.Future:complete({err}, {...})          *vim.async.Future:complete()*

    Mark the Future as complete and set its result.

    If an error is provided, the Future is marked as failed. Otherwise, it is
    marked as successful with the provided result.

    This will trigger any callbacks that are waiting on the Future.

    Parameters: ~
    - {err} (`any`)
    - {...} (`any`): result


==============================================================================
*vim.async.Queue*
------------------------------------------------------------------------------
vim.async.Queue:size()                                *vim.async.Queue:size()*

    Returns the number of items in the queue.

    Returns: ~
    - (`integer`)

------------------------------------------------------------------------------
vim.async.Queue:max_size()                        *vim.async.Queue:max_size()*

    Returns the maximum number of items in the queue.

    Returns: ~
    - (`integer?`)

------------------------------------------------------------------------------
vim.async.Queue:put({value})                           *vim.async.Queue:put()*

    Put an item into the queue.

    If the queue is full, wait until a free slot is available.

    Attributes: ~
    - `async`

    Parameters: ~
    - {value} (`any`)


------------------------------------------------------------------------------
vim.async.Queue:get()                                  *vim.async.Queue:get()*

    Get an item from the queue.

    If the queue is empty, wait until an item is available.

    Attributes: ~
    - `async`

    Returns: ~
    - (`any`)

------------------------------------------------------------------------------
vim.async.Queue:get_nowait()                    *vim.async.Queue:get_nowait()*

    Get an item from the queue without blocking.

    If the queue is empty, raise an error.

    Returns: ~
    - (`any`)

------------------------------------------------------------------------------
vim.async.Queue:put_nowait({value})             *vim.async.Queue:put_nowait()*

    Put an item into the queue without blocking.
    If no free slot is immediately available, raise "Queue is full" error.

    Parameters: ~
    - {value} (`any`)


==============================================================================
*vim.async.Semaphore*

A semaphore manages an internal counter which is decremented by each
`acquire()` call and incremented by each `release()` call. The counter can
never go below zero; when `acquire()` finds that it is zero, it blocks,
waiting until some task calls `release()`.

The preferred way to use a Semaphore is with the `with()` method, which
automatically acquires and releases the semaphore around a function call.

------------------------------------------------------------------------------
vim.async.Semaphore:with({fn})                    *vim.async.Semaphore:with()*

    Executes a function within the semaphore.

    This acquires the semaphore before running the function and releases it
    after the function completes, even if it errors.

    Attributes: ~
    - `async`

    Generics: ~
    - `R`

    Parameters: ~
    - {fn} (`async fun() -> R ...`): Function to execute within the semaphore's context.

    Returns: ~
    - (`R ...`): Result(s) of the executed function.

------------------------------------------------------------------------------
vim.async.Semaphore:acquire()                  *vim.async.Semaphore:acquire()*

    Acquire a semaphore.

    If the internal counter is greater than zero, decrement it by `1` and
    return immediately. If it is `0`, wait until a `release()` is called.

    Attributes: ~
    - `async`


------------------------------------------------------------------------------
vim.async.Semaphore:release()                  *vim.async.Semaphore:release()*

    Release a semaphore.

    Increments the internal counter by `1`. Can wake
    up a task waiting to acquire the semaphore.


==============================================================================
*vim.async.Task*

Tasks are used to run coroutines in event loops. If a coroutine needs to
wait on the event loop, the Task suspends the execution of the coroutine and
waits for event loop to restart it.

Use the |vim.async.run()| to create Tasks.

To close a running Task use the `close()` method. Calling it will cause the
Task to throw a "closed" error in the wrapped coroutine.

Note a Task can be waited on via more than one waiter.

------------------------------------------------------------------------------
*vim.async.Task.name*
    Type: `string?


    Mark task for internal use. Used for awaiting children tasks on complete.


------------------------------------------------------------------------------
vim.async.Task:completed()                        *vim.async.Task:completed()*

    Returns whether the Task has completed.

    Returns: ~
    - (`boolean`)

------------------------------------------------------------------------------
vim.async.Task:wait({callback_or_timeout})             *vim.async.Task:wait()*

    Add a callback to be run when the Task has completed.

    - If a timeout or `nil` is provided, the Task will synchronously wait for the
    task to complete for the given time in milliseconds.

    >lua
       local result = task:wait(10) -- wait for 10ms or else error

       local result = task:wait() -- wait indefinitely
<

    - If a function is provided, it will be called when the Task has completed
    with the arguments:
    - (`err: string`) - if the Task completed with an error.
    - (`nil`, `...:any`) - the results of the Task if it completed successfully.


    If the Task is already done when this method is called, the callback is
    called immediately with the results.

    Overloads: ~
    - `fun(timeout: integer?) -> R ...`

    Parameters: ~
    - {callback_or_timeout} (`(integer|fun(err: any, ...: R ...))?`)

    Returns: ~
    - (`any ...?`)

------------------------------------------------------------------------------
vim.async.Task:pwait({timeout})                       *vim.async.Task:pwait()*

    Protected-call version of `wait()`.

    Does not throw an error if the task fails or times out. Instead, returns
    the status and the results.

    Parameters: ~
    - {timeout} (`integer?`)

    Returns: ~
    - (`boolean`)
    - (`R ...`)

------------------------------------------------------------------------------
vim.async.Task:detach()                              *vim.async.Task:detach()*

    Detach a task from its parent.

    The task becomes a top-level task.

    Returns: ~
    - (`vim.async.Task`) (See |vim.async.Task|)

------------------------------------------------------------------------------
vim.async.Task:traceback({msg}, {level})          *vim.async.Task:traceback()*

    Get the traceback of a task when it is not active.
    Will also get the traceback of nested tasks.

    Parameters: ~
    - {msg} (`string?`)
    - {level} (`integer?`)

    Returns: ~
    - {traceback} (`string`)

------------------------------------------------------------------------------
vim.async.Task:raise_on_error()              *vim.async.Task:raise_on_error()*

    If a task completes with an error, raise the error

    Returns: ~
    - {self} (`vim.async.Task`) (See |vim.async.Task|)

------------------------------------------------------------------------------
vim.async.Task:close({callback})                      *vim.async.Task:close()*

    Close the task and all of its children.
    If callback is provided it will run asynchronously,
    else it will run synchronously.

    Parameters: ~
    - {callback} (`(fun())?`)


------------------------------------------------------------------------------
vim.async.Task:complete({...})                     *vim.async.Task:complete()*

    Complete a task with the given values, cancelling any remaining work.

    This marks the task as successfully completed and notifies any waiters with
    the provided values. It also initiates the cancellation of all
    running child tasks.

    A primary use case is for "race" scenarios. A child task can acquire a
    reference to its parent task and call `complete()` on it. This signals
    that the overall goal of the parent scope has been met, which immediately
    triggers the cancellation of all sibling tasks.

    This provides a built-in pattern for "first-to-finish" logic, such as
    querying multiple data sources and taking the first response.

    Parameters: ~
    - {...} (`any`): The values to complete the task with.


------------------------------------------------------------------------------
vim.async.Task:status()                              *vim.async.Task:status()*

    Returns the status of the task:
    - 'running'    : task is running (that is, is called `status()`).
    - 'normal'     : task is active but not running (e.g. it is starting
    another task).
    - 'awaiting'   : if the task is awaiting another task either directly via
    `await()` or waiting for all children to complete.
    - 'completed'  : task and all it's children have completed

    Returns: ~
    - (`("running"|"awaiting"|"normal"|"scheduled"|"completed")`)

==============================================================================
*vim.async.run.Opts*
------------------------------------------------------------------------------
*vim.async.run.Opts.name*
    Type: `string?


------------------------------------------------------------------------------
*vim.async.run.Opts.detached*
    Type: `boolean?


vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
